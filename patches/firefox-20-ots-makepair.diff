diff --git a/gfx/ots/src/cff.cc b/gfx/ots/src/cff.cc
index 3b0c14a..216235d 100644
--- a/gfx/ots/src/cff.cc
+++ b/gfx/ots/src/cff.cc
@@ -187,13 +187,13 @@ bool ParseDictDataBcd(
       if ((nibble & 0xf) == 0xf) {
         // TODO(yusukes): would be better to store actual double value,
         // rather than the dummy integer.
-        operands->push_back(std::make_pair(0, DICT_OPERAND_REAL));
+        operands->push_back(std::make_pair((unsigned)0, DICT_OPERAND_REAL));
         return true;
       }
       return OTS_FAILURE();
     }
     if ((nibble & 0x0f) == 0x0f) {
-      operands->push_back(std::make_pair(0, DICT_OPERAND_REAL));
+      operands->push_back(std::make_pair((unsigned)0, DICT_OPERAND_REAL));
       return true;
     }
 
@@ -262,7 +262,7 @@ bool ParseDictDataNumber(
           !table->ReadU8(&b2)) {
         return OTS_FAILURE();
       }
-      operands->push_back(std::make_pair((b1 << 8) + b2, DICT_OPERAND_INTEGER));
+      operands->push_back(std::make_pair((unsigned)((b1 << 8) + b2), DICT_OPERAND_INTEGER));
       return true;
 
     case 29:  // longint
@@ -272,8 +272,8 @@ bool ParseDictDataNumber(
           !table->ReadU8(&b4)) {
         return OTS_FAILURE();
       }
-      operands->push_back(std::make_pair(
-          (b1 << 24) + (b2 << 16) + (b3 << 8) + b4, DICT_OPERAND_INTEGER));
+      operands->push_back(std::make_pair((unsigned)
+          ((b1 << 24) + (b2 << 16) + (b3 << 8) + b4), DICT_OPERAND_INTEGER));
       return true;
 
     case 30:  // binary coded decimal
@@ -315,7 +315,7 @@ bool ParseDictDataReadNext(
     if (op == 12) {
       return ParseDictDataEscapedOperator(table, operands);
     }
-    operands->push_back(std::make_pair(op, DICT_OPERATOR));
+    operands->push_back(std::make_pair((unsigned)op, DICT_OPERATOR));
     return true;
   } else if (op <= 27 || op == 31 || op == 255) {
     // reserved area.
diff --git a/gfx/ots/src/cmap.cc b/gfx/ots/src/cmap.cc
index f90a324..9b7ac19 100644
--- a/gfx/ots/src/cmap.cc
+++ b/gfx/ots/src/cmap.cc
@@ -648,9 +648,9 @@ bool ots_cmap_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {
       continue;
     }
     overlap_checker.push_back(
-        std::make_pair(subtable_headers[i].offset, 1 /* start */));
+        std::make_pair(subtable_headers[i].offset, (uint8_t)1 /* start */));
     overlap_checker.push_back(
-        std::make_pair(end_byte, 0 /* end */));
+        std::make_pair(end_byte, (uint8_t)0 /* end */));
   }
   std::sort(overlap_checker.begin(), overlap_checker.end());
   int overlap_count = 0;
diff --git a/gfx/ots/src/glyf.cc b/gfx/ots/src/glyf.cc
index 69fcc02..4ef3794 100644
--- a/gfx/ots/src/glyf.cc
+++ b/gfx/ots/src/glyf.cc
@@ -118,7 +118,7 @@ bool ParseSimpleGlyph(ots::OpenTypeFile *file, const uint8_t *data,
     // a pointer to a static uint16_t 0 to overwrite the length.
     glyf->iov.push_back(std::make_pair(
         data + gly_offset, gly_header_length - 2));
-    glyf->iov.push_back(std::make_pair((const uint8_t*) "\x00\x00", 2));
+    glyf->iov.push_back(std::make_pair((const uint8_t*) "\x00\x00", (unsigned)2));
   }
 
   if (!table->Skip(bytecode_length)) {
diff --git a/gfx/ots/src/ots.cc b/gfx/ots/src/ots.cc
index b2b733e..5e829b5 100644
--- a/gfx/ots/src/ots.cc
+++ b/gfx/ots/src/ots.cc
@@ -394,9 +394,9 @@ bool ProcessGeneric(ots::OpenTypeFile *header, ots::OTSStream *output,
   std::vector<std::pair<uint32_t, uint8_t> > overlap_checker;
   for (unsigned i = 0; i < header->num_tables; ++i) {
     overlap_checker.push_back(
-        std::make_pair(tables[i].offset, 1 /* start */));
+        std::make_pair(tables[i].offset, (uint8_t)1 /* start */));
     overlap_checker.push_back(
-        std::make_pair(tables[i].offset + tables[i].length, 0 /* end */));
+        std::make_pair(tables[i].offset + tables[i].length, (uint8_t)0 /* end */));
   }
   std::sort(overlap_checker.begin(), overlap_checker.end());
   int overlap_count = 0;
