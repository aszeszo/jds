--- gdm-2.30.7/gui/simple-greeter/gdm-languages.c.org	Tue Jul 12 13:40:00 2011
+++ gdm-2.30.7/gui/simple-greeter/gdm-languages.c	Tue Jul 12 15:48:26 2011
@@ -27,6 +27,9 @@
 #include <stdio.h>
 #include <unistd.h>
 #include <string.h>
+#if __sun
+#include <strings.h>
+#endif
 #include <errno.h>
 #include <dirent.h>
 #include <locale.h>
@@ -147,7 +150,7 @@ gdm_parse_language_name (const char *nam
 
         if (!g_regex_match (re, name, 0, &match_info) ||
             g_match_info_is_partial_match (match_info)) {
-                g_warning ("locale %s isn't valid\n", name);
+		 g_debug ("locale %s isn't valid\n", name);
                 goto out;
         }
 
@@ -193,6 +196,12 @@ gdm_parse_language_name (const char *nam
                 }
         }
 
+	/*
+	 * While Solaris now supports locale aliases but we still prefer
+	 * unnormalized, canonical locale names. Hence, we do not normalize
+	 * codeset part of locale names.
+	 */
+#ifndef __sun
         if (codesetp != NULL && *codesetp != NULL) {
                 normalized_codeset = normalize_codeset (*codesetp);
                 normalized_name = construct_language_name (language_codep ? *language_codep : NULL,
@@ -208,6 +217,7 @@ gdm_parse_language_name (const char *nam
                 }
                 g_free (normalized_name);
         }
+#endif
 
  out:
         g_match_info_free (match_info);
@@ -357,9 +367,16 @@ out:
         return has_translations;
 }
 
+#if __sun
+static gboolean
+add_locale (const char *language_name,
+            gboolean    utf8_only,
+	    gboolean    verify_locale)
+#else
 static gboolean
 add_locale (const char *language_name,
             gboolean    utf8_only)
+#endif
 {
         GdmLocale *locale;
         GdmLocale *old_locale;
@@ -368,6 +385,13 @@ add_locale (const char *language_name,
 
         g_return_val_if_fail (language_name != NULL, FALSE);
 
+#if __sun
+	if (strstr(language_name, ".UTF-8") != NULL || !utf8_only) {
+		name = g_strdup (language_name);
+	} else {
+               return FALSE;
+       }
+#else
         language_name_get_codeset_details (language_name, NULL, &is_utf8);
 
         if (is_utf8) {
@@ -384,11 +408,21 @@ add_locale (const char *language_name,
                 name = g_strdup (language_name);
         }
 
+#endif
+
+#if __sun
+        if (verify_locale && !language_name_is_valid (name)) {
+                g_warning ("Your locale '%s' was failed by setlocale()", name);
+                g_free (name);
+                return FALSE;
+        }
+#else
         if (!language_name_is_valid (name)) {
                 g_debug ("Ignoring '%s' as a locale, since it's invalid", name);
                 g_free (name);
                 return FALSE;
         }
+#endif
 
         locale = g_new0 (GdmLocale, 1);
         gdm_parse_language_name (name,
@@ -399,6 +433,13 @@ add_locale (const char *language_name,
         g_free (name);
         name = NULL;
 
+#if __sun
+	if (locale->language_code == NULL) {
+		gdm_locale_free (locale);
+		return FALSE;
+	}
+#endif
+
 #ifdef WITH_INCOMPLETE_LOCALES
         if (utf8_only) {
                 if (locale->territory_code == NULL || locale->modifier) {
@@ -467,7 +508,7 @@ collect_locales_from_archive (void)
         if (mapped == NULL) {
                 mapped = g_mapped_file_new (SYSTEM_ARCHIVE_FILE, FALSE, NULL);
                 if (mapped == NULL) {
-                        g_warning ("Mapping failed for %s: %s", ARCHIVE_FILE, error->message);
+                        g_debug ("Mapping failed for %s: %s", ARCHIVE_FILE, error->message);
                         g_error_free (error);
                         return FALSE;
                 }
@@ -498,7 +539,11 @@ collect_locales_from_archive (void)
         }
 
         for (cnt = 0; cnt < used; ++cnt) {
+#if __sun
+                add_locale (names[cnt].name, TRUE, TRUE);
+#else
                 add_locale (names[cnt].name, TRUE);
+#endif
         }
 
         g_free (names);
@@ -543,6 +588,19 @@ select_dirs (const struct dirent *dirent
 static void
 collect_locales_from_directory (void)
 {
+#if __sun
+	lclist_t *lclp;
+	int       count;
+	int       i;
+
+	count = localelist (&lclp, LCLIST_QUERY);
+
+	for (i = 0; i < count; i++) {
+		add_locale (lclp[i].locale, TRUE, FALSE);
+	}
+
+	localelistfree (lclp);
+#else
         struct dirent **dirents;
         int             ndirents;
         int             cnt;
@@ -556,6 +614,7 @@ collect_locales_from_directory (void)
         if (ndirents > 0) {
                 free (dirents);
         }
+#endif
 }
 
 static void
@@ -601,9 +660,15 @@ collect_locales_from_locale_file (const 
 
                 lang = NULL;
                 for (i = 0; lang_list[i] != NULL; i++) {
+#if __sun
+                        if (add_locale (lang_list[i], FALSE, TRUE)) {
+                                break;
+                        }
+#else
                         if (add_locale (lang_list[i], FALSE)) {
                                 break;
                         }
+#endif
                 }
                 g_strfreev (lang_list);
         }
@@ -706,7 +771,7 @@ get_translated_language (const char *cod
                 }
 
                 if (is_fallback_language (code)) {
-                        name = g_strdup (_("Unspecified"));
+			name = g_strdup (code);
                 } else {
                         translated_name = dgettext ("iso_639", language);
                         name = get_first_item_in_semicolon_list (translated_name);
@@ -1096,6 +1161,11 @@ gdm_get_language_from_name (const char *
 
         full_language = g_string_append (full_language, translated_language);
 
+	if (strcmp (translated_language, "C") == 0 ||
+	    strcmp (translated_language, "POSIX") == 0) {
+		goto out;
+	}
+
         if (territory_code != NULL) {
                 translated_territory = get_translated_territory (territory_code, locale);
         }
