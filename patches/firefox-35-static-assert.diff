diff --git a/content/base/public/nsINode.h b/content/base/public/nsINode.h
--- a/content/base/public/nsINode.h
+++ b/content/base/public/nsINode.h
@@ -1141,32 +1141,32 @@ private:
     ElementHasName,
     // Set if the element might have a contenteditable attribute set.
     ElementMayHaveContentEditableAttr,
     // Guard value
     BooleanFlagCount
   };
 
   void SetBoolFlag(BooleanFlag name, bool value) {
-    PR_STATIC_ASSERT(BooleanFlagCount <= 8*sizeof(mBoolFlags));
+    PR_STATIC_ASSERT(BooleanFlagCount <= 8*4);
     mBoolFlags = (mBoolFlags & ~(1 << name)) | (value << name);
   }
 
   void SetBoolFlag(BooleanFlag name) {
-    PR_STATIC_ASSERT(BooleanFlagCount <= 8*sizeof(mBoolFlags));
+    PR_STATIC_ASSERT(BooleanFlagCount <= 8*4);
     mBoolFlags |= (1 << name);
   }
 
   void ClearBoolFlag(BooleanFlag name) {
-    PR_STATIC_ASSERT(BooleanFlagCount <= 8*sizeof(mBoolFlags));
+    PR_STATIC_ASSERT(BooleanFlagCount <= 8*4);
     mBoolFlags &= ~(1 << name);
   }
 
   bool GetBoolFlag(BooleanFlag name) const {
-    PR_STATIC_ASSERT(BooleanFlagCount <= 8*sizeof(mBoolFlags));
+    PR_STATIC_ASSERT(BooleanFlagCount <= 8*4);
     return mBoolFlags & (1 << name);
   }
 
 public:
   bool HasRenderingObservers() const
     { return GetBoolFlag(NodeHasRenderingObservers); }
   void SetHasRenderingObservers(bool aValue)
     { SetBoolFlag(NodeHasRenderingObservers, aValue); }
diff --git a/content/media/wave/nsWaveReader.cpp b/content/media/wave/nsWaveReader.cpp
--- a/content/media/wave/nsWaveReader.cpp
+++ b/content/media/wave/nsWaveReader.cpp
@@ -404,17 +404,17 @@ nsWaveReader::LoadFormatChunk()
     return PR_FALSE;
   }
 
   PR_STATIC_ASSERT(sizeof(PRUint16) +
                    sizeof(PRUint16) +
                    sizeof(PRUint32) +
                    4 +
                    sizeof(PRUint16) +
-                   sizeof(PRUint16) <= sizeof(waveFormat));
+                   sizeof(PRUint16) <= WAVE_FORMAT_CHUNK_SIZE);
   if (ReadUint16LE(&p) != WAVE_FORMAT_ENCODING_PCM) {
     NS_WARNING("WAVE is not uncompressed PCM, compressed encodings are not supported");
     return PR_FALSE;
   }
 
   channels = ReadUint16LE(&p);
   rate = ReadUint32LE(&p);
 
@@ -433,17 +433,17 @@ nsWaveReader::LoadFormatChunk()
   if (fmtSize > WAVE_FORMAT_CHUNK_SIZE) {
     char extLength[2];
     const char* p = extLength;
 
     if (!ReadAll(extLength, sizeof(extLength))) {
       return PR_FALSE;
     }
 
-    PR_STATIC_ASSERT(sizeof(PRUint16) <= sizeof(extLength));
+    PR_STATIC_ASSERT(sizeof(PRUint16) <= 2);
     PRUint16 extra = ReadUint16LE(&p);
     if (fmtSize - (WAVE_FORMAT_CHUNK_SIZE + 2) != extra) {
       NS_WARNING("Invalid extended format chunk size");
       return PR_FALSE;
     }
     extra += extra % 2;
 
     if (extra > 0) {
